<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>clearley.defrule documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clearley 0.3.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="clearley.core.html"><span>clearley.core</span></a></li><li class="current"><a href="clearley.defrule.html"><span>clearley.defrule</span></a></li><li><a href="clearley.grammar.html"><span>clearley.grammar</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="clearley.defrule.html#var-bind"><span>bind</span></a></li><li><a href="clearley.defrule.html#var-char-range"><span>char-range</span></a></li><li><a href="clearley.defrule.html#var-defbind"><span>defbind</span></a></li><li><a href="clearley.defrule.html#var-defrule"><span>defrule</span></a></li><li><a href="clearley.defrule.html#var-empty-rule"><span>empty-rule</span></a></li><li><a href="clearley.defrule.html#var-match"><span>match</span></a></li><li><a href="clearley.defrule.html#var-opt"><span>opt</span></a></li><li><a href="clearley.defrule.html#var-or-rule"><span>or-rule</span></a></li><li><a href="clearley.defrule.html#var-plus"><span>plus</span></a></li><li><a href="clearley.defrule.html#var-rule"><span>rule</span></a></li><li><a href="clearley.defrule.html#var-scanner"><span>scanner</span></a></li><li><a href="clearley.defrule.html#var-string-rule"><span>string-rule</span></a></li><li><a href="clearley.defrule.html#var-symbol-rule"><span>symbol-rule</span></a></li><li><a href="clearley.defrule.html#var-token"><span>token</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>clearley.defrule documentation</h2><pre class="doc">Fns and macros to define context-free grammars.
Emphasis is on power, flexibility, and ease of use.</pre><div class="public" id="var-bind"><h3>bind</h3><h4 class="macro">macro</h4><div class="usage"><code>(bind binding-forms &amp; body)</code></div><pre class="doc">A format for defining a rule and an action that binds to some subrules.
Syntax is as in let, except the binding values are rules.

Example:
(letrule [a rule1
          b `(:or rule2-1 rule2-2)
          [c d] rule3]
  (str rule1 rule2 rule3))</pre></div><div class="public" id="var-char-range"><h3>char-range</h3><div class="usage"><code>(char-range min max)</code><code>(char-range min max action)</code></div><pre class="doc">Creates a rule that accepts any one character within a given range
given by min and max, inclusive. min and max should be chars. The default
action is the identity.</pre></div><div class="public" id="var-defbind"><h3>defbind</h3><h4 class="macro">macro</h4><div class="usage"><code>(defbind sym &amp; body)</code></div><pre class="doc">Like bind but defs a variable.
</pre></div><div class="public" id="var-defrule"><h3>defrule</h3><h4 class="macro">macro</h4><div class="usage"><code>(defrule sym &amp; impl-or-impls)</code></div><pre class="doc">Defines a rule and an action together. This macro is intended to be
the primary way to def rules.

Usage:
(defrule symbol [subrules] action-body?)
(defrule symbol ([subrules] action-body? | symbol)+)
Subrules may be a vector or a string. It can contain any rule,
but if it's a symbol, this can bind symbols in the action body.

Examples:

(defrule true-token &quot;true&quot; true)
This matches the string &quot;true&quot; and returns true.

(defrule sum [num \+ (num2 num)] (+ num num2)
             [num \- (num2 num)] (- num num2))
This matches any num, followed by + or -, followed by another num,
and returns the value of adding or subtracting the two respectively.

(defrule num ([\- posnum] (- posnum))
              posnum)
This matches any posnum preceded by -, returning the negation of posnum.
Or it can match a posnum directly, and return the posnum (default).

You can embed rules in named subrules, viz:
(defrule digit [(x (char-range 0 9))] x)

Symbols in the defrule bodies do not become qualified.</pre></div><div class="public" id="var-empty-rule"><h3>empty-rule</h3><div class="usage"></div><pre class="doc">The empty rule. Returns nil.
</pre></div><div class="public" id="var-match"><h3>match</h3><h4 class="macro">macro</h4><div class="usage"><code>(match clauses &amp; body)</code></div><pre class="doc">Defines a rule together with an action. If a subrule is a symbol,
it can be bound to symbols in the action body. You can also supply a
renaming binding symbol.

Examples:

(match [\- num (- num))
(match [(num1 num) \+ (num2 num)] (+ num1 num2))</pre></div><div class="public" id="var-opt"><h3>opt</h3><div class="usage"><code>(opt a-rule)</code><code>(opt a-rule action)</code></div><pre class="doc">Creates a rule that matches a subrule, or nothing. The action will be passed
the subrule's value, or nil. The default action is the identity.</pre></div><div class="public" id="var-or-rule"><h3>or-rule</h3><div class="usage"><code>(or-rule rules)</code><code>(or-rule rules action)</code><code>(or-rule name rules action)</code></div><pre class="doc">Creates a rule that matches one of some number of given rules. The default
action is the identity.</pre></div><div class="public" id="var-plus"><h3>plus</h3><div class="usage"><code>(plus a-rule)</code><code>(plus a-rule action)</code></div><pre class="doc">Creates a rule that matches one or more of some subrule.
The defalt action returns a seq of the args.</pre></div><div class="public" id="var-rule"><h3>rule</h3><div class="usage"><code>(rule clauses)</code><code>(rule clauses action)</code><code>(rule name clauses action)</code></div><pre class="doc">Creates a context-free grammar rule. A rule has a required seq of clauses,
an optional name, and an optional action.
If not supplied, the default action bundles the args into a list.</pre></div><div class="public" id="var-scanner"><h3>scanner</h3><div class="usage"><code>(scanner scanner-fn)</code><code>(scanner scanner-fn action)</code><code>(scanner name scanner-fn action)</code></div><pre class="doc">Creates a rule that accepts input tokens. For a token t, if (scanner-fn t)
is logical true, this rule matches that token.
The default action returns the token.</pre></div><div class="public" id="var-string-rule"><h3>string-rule</h3><div class="usage"><code>(string-rule str)</code><code>(string-rule str action)</code></div><pre class="doc">Creates a rule that matches some string. The default action returns the string.
</pre></div><div class="public" id="var-symbol-rule"><h3>symbol-rule</h3><div class="usage"><code>(symbol-rule a-symbol)</code><code>(symbol-rule a-symbol action)</code><code>(symbol-rule name a-symbol action)</code></div><pre class="doc">Creates a rule that points to some other rule, identified by the given symbol.
The default action is the identity.</pre></div><div class="public" id="var-token"><h3>token</h3><div class="usage"><code>(token a-token)</code><code>(token a-token action)</code><code>(token name a-token action)</code></div><pre class="doc">Creates a rule that matches a token. The default action returns the token.
</pre></div></div></body></html>