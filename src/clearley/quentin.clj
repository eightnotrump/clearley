(ns clearley.quentin
  (require [uncore.throw :as t]
           [uncore.str :as s]
           [clearley.rules :as rules]
           [uncore.collections.worm-ordered-multimap :as omm]
           clojure.stacktrace clojure.pprint)
  (:refer-clojure :exclude [compile])
  (import clearley.ParseState clearley.TransientParseState
          java.util.ArrayList)
  (use clearley.clr uncore.core uncore.memo))
; TODO what does aot do?
; TODO eliminate state, then have parser return results.
; TODO do we need locking?
;
; TODO a lot of this is ugly. One thing we can do is put deterministic item parsers
; in protocols (we will need to do this anyway). Then extra generated methods
; can be statically linked.

(def ^:dynamic *myns*)

(defn- compile [f]
  (try (binding [*ns* *myns*]
         (eval f))
    (catch Exception e
      (binding [*out* *err*]
        (println "Exception compiling")
        (clojure.pprint/pprint f))
      (throw e))))

(defn parse-stream [input]
  (TransientParseState. (seq input)))

; The core abstraction is
; Parse stream handler: parse stream -> parse stream
(declare continue-parsing item-parser-sym embed-parser-with-lookahead)

; For a factory seed, obj, and a factory method, factory,
; looks up the value created by the seed obj in the given namespace's map.
; If it doesn't exist, creates it, interns it, and returns the sym.
(defn get-or-bind [obj factory a-str]
  (let [item-set-var-map @(ns-resolve *myns* 'item-set-var-map)
        ns-lock @(ns-resolve *myns* 'ns-lock)]
    (locking ns-lock
      (let [sym (symbol (str a-str "-" (count (get @item-set-var-map a-str {}))))]
        (if-let [sym0 (get-in @item-set-var-map [a-str obj])]
          sym0
          (let [r (factory obj)]
            (println (s/cutoff (str "Interning " sym " : " r) 80))
            (intern *myns* sym r)
            (swap! item-set-var-map #(assoc-in % [a-str obj] sym))
            sym))))))

; An evil way to def a thunk that, when called, generates a fn and redefs the sym
; to the fn! Returns the bound symbol.
(defn lookup-thunk [key candidate-thunk a-str]
  (let [item-set-var-map @(ns-resolve *myns* 'item-set-var-map)
        ns-lock @(ns-resolve *myns* 'ns-lock)]
    (locking ns-lock
      (let [sym (symbol (str a-str "-" (count (get @item-set-var-map a-str {}))))]
        (if-let [sym0 (get-in @item-set-var-map [a-str key])]
          sym0
          ; Assumption: thunk has no side effects
          (let [thunk (fn [& args]
                        (let [r (candidate-thunk)]
                          (println (s/cutoff (str "Interning " sym " : " r) 80))
                          (intern *myns* sym r)
                          (apply r args)))]
            (intern *myns* sym thunk)
            (swap! item-set-var-map #(assoc-in % [a-str key] sym))
            sym))))))

(defn item-id [item]
  (generate ::item item (fn [_ id] id)))

(defn fail [^ParseState stream] (t/RE "Failure to parse at position: " (.pos stream)))

; === Advance loops ===

; Creates an interleaved seq of case-num, body pairs for splicing into a case.
; Produces, (1 2 3) foo, where 1 2 3 are generated by case-label-fn and grouped
; by case-key-fn, and the bodies are done by calling case-body-fn on the keys.
(defn collate-cases [case-label-fn case-key-fn case-body-fn vals]
  (mapcat (fn [[k ls]]
            (list (apply list ls) (case-body-fn k)))
          (reduce (fn [k->ls v]
                    (if-let [k (case-key-fn v)]
                      (assoc k->ls k (conj (get k->ls k []) (case-label-fn v)))
                      k->ls))
                  {} vals)))

; TODO get state-split conflicts
; Anaphoric, needs a ~'result and a wrapping loop/recur and a ~'state
; For a backlink, calls the item-parser represented by that advance,
; and either looks up and recurs to a main branch, or calls the continuance.
(defn gen-advance-handler [shift-advance]
  `(recur (~(item-parser-sym shift-advance ['v0])
              ~'state
              (.returnValue ~'state))))

; TODO redoc
; TODO we can make this smaller since we know
; a token consuming shift only happens once
; For an item set, builds the 'continuing table' which handles all steps after
; the first initial shift. Implemented as a loop/recur with a case branch.
; The branch table matches all possible advances (advancing shifts, continues)
; to the appropriate branch. The appropriate branch either recurs (advancing shift)
; or calls the next item set (continue).
(defn gen-advance-loop [{backlink-map :backlink-map :as item-set}]
  `(loop [~'state ~'state]
     (case (.getGoto ~(apply symbol '(^ParseState state)))
       ~@(collate-cases item-id #(advance-item-set item-set % false)
                        gen-advance-handler (omm/keys backlink-map))
       ~'state))) ; Return and let parent item-set-parser pick it up

; Creates an advancer fn. Takes in a parse state and an ArrayList partial match.
(defn advance-looper [item-set]
  (let [r `(fn [~(apply symbol '(^ParseState state))]
      ;          ~(apply symbol '(^ArrayList partial-match))]
             ~(gen-advance-loop item-set))]
    ;(println "Advancer:") (clojure.pprint/pprint r)
    (compile r)))

(defn gen-body-parser [item-set]
  (lookup-thunk item-set #(advance-looper item-set) "advancer"))

(defn action-sym [action] (get-or-bind action identity "action"))
(defn scanner-sym [scanner] (get-or-bind scanner identity "scanner"))
(defn item-sym [item] (get-or-bind item identity "item"))

; === Shifts and scanning

; Requires 'input, 'state, 'advancer, and 'partial-match.
; Returns a code snippet for handling a state after a scanner is matched.
; Can either take action and return, or call a advancer returning the result.
(defn gen-scanner-handler [scanner item-set action-map working-syms]
  (let [shift (get-actions-for-tag scanner action-map :shift)
        return (get-actions-for-tag scanner action-map :return)]
    (if (> (count return) 1)
      (do
        (println "Reduce-reduce conflict in item set\n" (item-set-str item-set))
        (println "for items" (s/separate-str " " (map item-str-follow return)))))
    (if (seq shift)
      (do
        (if (seq return)
          (println "Shift-reduce conflict in item set\n" (item-set-str item-set)))
        [:shift [scanner
                 `(~(item-parser-sym (pep-item-set (map advance-item shift)) ['v0])
                      (.shift ~'state ~'input)
                      ~'input)]])
      (let [ritem (first return) ; ignore reduce-reduce for now
            r-action (-> ritem :rule rules/get-original :action)
            r-backlink (-> ritem :backlink item-id)]
        [:return [scanner
                  `(do
                     (.setReturnValue ~'state (~(action-sym r-action)
                                                    ~@working-syms))
                     (.reduce ~'state ~(item-sym (first return))
                              ~r-backlink))]]))))

; A cond chain for all actions
; TODO unify with gen-parser-body
(defn gen-seed-parser [item-set working-syms]
  (let [action-map (action-map item-set)
        cond-pair-fn (fn [[scanner code]]
                       [(list (scanner-sym scanner) 'input) code])
        handlers (map #(gen-scanner-handler % item-set action-map working-syms)
                      (remove #(= :clearley.clr/term %) (omm/keys action-map)))
        return-handlers (untag handlers :return)
        shift-handlers (untag handlers :shift)
        next-sym (symbol (str "v" (count working-syms)))
        [_ [_ term-handler]] (gen-scanner-handler :clearley.clr/term item-set
                                                  action-map working-syms)]

    ; Special handling for terminus (terminus always returns, BTW)
    `(cond (empty? ~'istream) ~(if term-handler term-handler `(fail ~'state))
           ; See if we should return
           ~@(mapcat cond-pair-fn return-handlers)
           ; Shift, get the result, continue with the result
           true (let [~'state (cond ~@(mapcat cond-pair-fn shift-handlers)
                                    true (fail ~'state))
                      ~'state (~(gen-body-parser item-set) ~'state)
                      ~'istream (.input ~'state)
                      ~'input (first ~'istream)
                      ~next-sym (.returnValue ~'state)]
                  (case (.getGoto ~'state)
                    ~@(collate-cases item-id #(advance-item-set item-set % true)
                                     (fn [item-set]
                                       (gen-seed-parser
                                         item-set (conj working-syms next-sym)))
                                     (omm/keys (:backlink-map item-set))))))))

; For when we already know the lookahead state (resolved from a lookahead reduce).
; This is compact enough we can put it inline.
; TODO
#_(defn embed-parser-with-lookahead [item-set lookahead]
  (let [[_ [_ code]] (gen-scanner-handler lookahead item-set (action-map item-set))]
    (if (= :clearley.clr/term lookahead)
      code
      `(let [~'input (first (.input ~'state))]
         ~code))))

; Sets up all the stuff to execute gen-initial-shift
(defn gen-parser-body [item-set initial-symbols]
  (let [r `(fn [~(apply symbol '(^ParseState state))
                ~@initial-symbols]
             (let [~'istream (.input ~'state)
                   ~'input (first ~'istream)]
               ~(gen-seed-parser item-set initial-symbols)))
    f (compile r)]
    (clojure.pprint/pprint "item-set") (println (item-set-str item-set))
    (clojure.pprint/pprint "parser") (clojure.pprint/pprint r)
    f
    #_(fn [& args]
        ;(println "Parsing item set")
        ;(print (item-set-str item-set))
        ;(println "with code")
        ;(clojure.pprint/pprint r)
        (apply f args))))

(defn item-parser-sym [^clearley.clr.ItemSet item-set initial-symbols]
  (when item-set
    (lookup-thunk [(item-set-key item-set) (count initial-symbols)]
                  (fn []
                    ;(println "Loading code for item set:")
                    ;(println (item-set-str item-set))
                    (println "Compiling item parser...")
                    (gen-parser-body item-set initial-symbols)) "item-parser")))

(defn new-ns []
  (let [sym (gensym "quentin")
        r (create-ns sym)]
    ;(remove-ns sym) ; TODO
    (binding [*ns* r]
      (use 'clojure.core 'clearley.quentin)
      (import 'clearley.ParseState 'java.util.ArrayList))
    (intern r 'item-set-var-map (atom {})) ; map: seeds -> symbol
    (intern r 'ns-lock (Object.))
    r))

(defn parse [grammar goal input myns mem]
  (try
    (with-memoizer mem
      (binding [*myns* myns]
        (.returnValue
          (@(ns-resolve *myns*
                        (item-parser-sym (pep-item-set [(goal-item goal grammar)]) []))
              (parse-stream input)))))
    ; TODO the below
    (catch RuntimeException e (clojure.stacktrace/print-stack-trace e) nil)))
